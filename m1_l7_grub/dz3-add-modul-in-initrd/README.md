## Добавить модуль в initrd
******************************************************************************
Поскольку дистрибутивное ядро Linux не может включать в себя все возможные драйвера, критичные для загрузки на всем возможном оборудовании, а также не может загружаться сразу с разных RAID-массивов, LVM или по NFS, то ему в помощь применяется специальный образ сжатой файловой системы, который называется initramfs (Initial Ram Filesystem). В initramfs обычно встраиваются модули ядра, критичные для запуска системы (драйверы дискового контроллера, драйверы корневой файловой системы, а при необходимости и драйверы поддержки NFS, LVM и RAID) и специальный скрипт (называется или init или linuxrc), который и запускается на ранних стадиях загрузки и начинает искать раздел, несущий файловую систему. Именно он собирает софтовые RAID-массивы, активирует LVM и т.д и т.п. Затем, когда он находит корневую систему, то переключает корень системы на него (а на ранних стадиях роль временной корневой системы играет как раз initramfs) и дальше запускается системный init, который и ведет дальнейшую загрузку. Скорость инициализации в данном случае прямо скажем не ахти какая. 
Коль скоро при запуске системы все равно запускается udev, то и поиск корневой системы можно возложить на него. Более того, мы же все равно указываем корневой раздел в строке параметров ядра, поэтому и задача его поиска существенно упрощается. Теперь udev запускается прямо из initramfs, инициализирует все дисковые разделы, собирает RAID-массивы, LVM и т.п., а затем и передает управление скрипту, который находит корень и переключает дальнейшую загрузку на него. А то средство, которое и формирует новый initramfs назвали dracut. Причем, что здорово на мой взгляд, его опции для создания initramfs по-умолчанию аналогичны опциям хорошо известного администраторам RHEL и Fedora скрипта mkinitrd . Т.е. если раньше они для создания initramfs делали так:
`mkinitrd /boot/name_of_initramfs $(uname -r)`
то теперь для этого нужно только поменять имя запускаемой команды:
`dracut /boot/name_of_initramfs $(uname -r)`
При запуске dracut определяет какие модули ему необходимы для загрузки системы и формирует новый 
initramfs.
Dracut использует модульную систему для управления процессом загрузки. подобно инструментам initramfs, он обладает крюком, называемым pre-mount, который хотим использовать. Чтобы установить скрипт необходимо определить модуль, который использует этот hook. Модули для dracut расположены в `/usr/share/dracut/modules.d/` : в различных директориях
в каждой из которых лежит прежде всего скрипт: `module-setup.sh` - который устанавливает модуль и вызывает другие необходимые скрипты.
В нашем случае `module-setup.sh` выглядет так:
```sh
#!/bin/bash
check () {
    return 0
}
depends() {
    return 0
}
install() {
    inst_hook cleanup 00 "${moddir}/pinguin.sh"
}
```
В этом скрипте если позволить check () вернуть 255 вместо 0, модуль будет загружен только в том случае, если он указан в файле конфигурации dracut (возвращая 0, он будет загружен безоговорочно)
Скрипт `pinguin.sh` лежит в той же директории что и `module-setup.sh`
```sh
exec 0<>/dev/console 1<>/dev/console 2<>/dev/console
cat <<'msgend'
_______________________
< I'm dracut module  >
 -----------------------
   \
    \
        .--.
       |o_o |
       |:_/ |
      //   \ \
     (|     | )
    /'\_   _/'\
    \___)=(___/

msgend

sleep 10
echo "Continuing..."
sleep 1
```
Пересобираем образ initrd
`mkinitrd -f -v /boot/initramfs-$(uname -r).img $(uname -r)`
Можно проверить/посмотреть что наш модуль загружен в образ:
`lsinitrd -m /boot/initramfs-$(uname -r).img | grep pinguin`
Осталось только отключить параметры `rhgb` и `quiet` Тем самым отключив показ красивого, но бесполезного, экрана загрузки и вместо него можно будет видеть все логи и все ошибки, если они будут, а так же нашего пингвина при загрузке.
