# Простая защита от DDOS

Написать конфигурацию nginx, которая даёт доступ клиенту только с определенной cookie.
Если у клиента её нет, нужно выполнить редирект на location, в котором кука будет добавлена, после чего клиент будет обратно отправлен (редирект) на запрашиваемый ресурс.

Смысл: умные боты попадаются редко, тупые боты по редиректам с куками два раза не пойдут
*******************************************

Начальная установка nginx c конфигурацией выполнена: vagrant+ansible.
Немного теории.

### Cookies

С помощью cookies веб-браузеры контролируют состояние на стороне клиента. Cookie - это имя с присоединенным содержимым. Сервер при помощи отправки cookies сообщает клиенту путь и имя хоста, по которому в следующий раз должны быть отправлены cookies, сообщает время жизни cookies и некоторые другие параметры. 

Когда клиент соединяется с сервером по адресу, указанному в принятом cookie, клиент посылает этот cookie к серверу (если время жизни не истекло). 

Многие приложения и сервера используют этот метод, чтобы объединить нескольких запросов в одну логическую сессию. Чтобы curl также мог выполнять такую функцию, мы должны уметь сохранять и отправлять cookies, как и делают браузеры. 

Простейший способ отправить cookie к серверу при получении страницы с помощью curl, это добавить соответствующий ключ в командной строке:

`Curl` - инструмент командной строки, который позволяет проделывать URL-манипуляции и передачи различного рода. 

`curl -b "name=Daniel" www.cookiesite.com`

Cookies отправляются как обычные HTTP-заголовки. Это позволяет curl сохранять cookies, сохраняя заголовки. Сохранение cookies с помощью curl выполняется командой:

`curl -D headers_and_cookies www.cookiesite.com`

(кстати, для сохранения cookies лучше использовать ключ -c, ).

У curl имеется полнофункциональный обработчик cookies, который полезен, когда мы хотим соединиться в очередной раз к серверу и использовать cookies, сохраненные в прошлый раз (либо подработанные вручную). Для использования cookies, сохраненных в файле, вызовите curl так: 

`curl -b stored_cookies_in_file www.cookiesite.com`

"Cookie-движок" curl включается, когда мы указываем ключ -b. Если мы хотим, чтобы curl лишь воспринимал cookies, используем -b с указанием файла, которого не существует. Например, если вы хотите, чтобы curl принял cookies со страницы, а затем пошел по перенаправлению (возможно, отдав принятый только что cookie), то можно вызывать curl так:

`curl -b nada -L www.cookiesite.com`

Curl умеет читать и писать cookie-файлы, имеющие формат Netscape и Mozilla. Это удобный способ обмениваться cookies между браузерами и автоматическими скриптами. Ключ -b автоматически определяет, является ли данный файл cookie-файлом указанных браузеров и обрабатывает его соответствующим образом, а используя ключ -c/--cookie-jar, вы можете заставить curl записать новый cookie-файл по завершении операции: 

`curl -b cookies.txt -c newcookies.txt www.cookiesite.com`

В данном случае при формировании запросов будем пользоваться следующими ключами:

```
-b - сохранить Cookie в файл;

-c - Задать файл, в который будут записаны все куки после завершения команды. Туда будут записаны все прочитанные куки из файла и полученные от удаленного сервера

-i - (HTTP) Включить вывод HTTP заголовков, они включают в себя такую информацию как : имя сервера, дату документа, версию http и многое другое.
```

Для конфигурации nginx используем следующие модули:

Модуль `ngx_http_rewrite_module`, необходимый для настройки перенаправлений, он устанавливается автоматически вместе с Nginx. позволяет изменять URI запроса с помощью регулярных выражений PCRE, делать перенаправления и выбирать конфигурацию по условию

Модуль `ngx_http_headers_module`, позволяет выдавать поля заголовка “Expires” и “Cache-Control”, а также добавлять произвольные поля в заголовок ответа.
В частности понадобится директива `add_header`

```
 location / {
                if ($cookie_access != "otus-cookie") {
                  add_header "Set-Cookie" "query=$request_uri";
                  rewrite ^(.*)$ /setcookie redirect;
                }
        }
```
```
        location /setcookie {
                  add_header "Set-Cookie" "access=otus-cookie";
                  return 302 $cookie_query;
        }
```

Ну и в результате протестируем. Попробуем зайти без куки, получить её и зайти уже с куки:

`curl -b sirrax.txt -c sirrax.txt http://localhost/index.html -i`

![](https://raw.githubusercontent.com/sirrax/otus-linux/master/m3_l25_web/screen/1.png)

`curl -b sirrax.txt -c sirrax.txt http://localhost/setcookie -i`

![](https://raw.githubusercontent.com/sirrax/otus-linux/master/m3_l25_web/screen/2.png)

`curl -b sirrax.txt http://localhost/index.html -i`

![](https://raw.githubusercontent.com/sirrax/otus-linux/master/m3_l25_web/screen/3.png)


В выше приведенном случае использовалася оператор `if` в конфигурации. `if` в `nginx` реализован по своему, достаточно неочевидно. `if` в `nginx` — это из разряда, когда мир крутится вокруг вас, а не наоборот. На каждый if в location,nginx генерирует у себя два конфига, с `if=true` и с `if=false`.
Плюс, некоторые директивы ведут себя странно, или вообще не работают рядом с if в одном location. Поэтому при работе с if всегда есть шанс совсем не того поведения, которое вы ожидали. Для гарантированного поведения, if лучше заменять на `map`.

Я попробовал реализовать данную задачу следующим образом (конфиг `nginx_map.conf` прилагается):

```
map $cookie_access $isLocation {
    default " /setcookie";
    "otus-cookie " /usecookie";
    }

server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        include /etc/nginx/default.d/*.conf;

        location / {
             rewrite ^(.*)$isLocation redirect;
                }
        location /setcookie {
                  add_header "Set-Cookie" "access=otus-cookie";
                  rewrite ^(.*)$ /usecookie redirect;
        }
        location /usecookie {
        rewrite ^(.*)$ /usr/share/nginx/html/index.html break;
        }
```
Хочу отметить что хотя в этом случае map  и отрабатывает редиректами на необходимые локации в зависимость наличия куки. Но окончательного доступа к странице я так и не получил.

