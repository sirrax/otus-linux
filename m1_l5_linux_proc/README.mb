Домашнее задание
работаем с процессами
Задания на выбор
1) написать свою реализацию ps ax используя анализ /proc
- Результат ДЗ - рабочий скрипт который можно запустить
2) написать свою реализацию lsof
- Результат ДЗ - рабочий скрипт который можно запустить
3) дописать обработчики сигналов в прилагаемом скрипте, оттестировать, приложить сам скрипт, инструкции по использованию
- Результат ДЗ - рабочий скрипт который можно запустить + инструкция по использованию и лог консоли
4) реализовать 2 конкурирующих процесса по IO. пробовать запустить с разными ionice
- Результат ДЗ - скрипт запускающий 2 процесса с разными ionice, замеряющий время выполнения и лог консоли
5) реализовать 2 конкурирующих процесса по CPU. пробовать запустить с разными nice
- Результат ДЗ - скрипт запускающий 2 процесса с разными nice и замеряющий время выполнения и лог консоли
Критерии оценки: 5 баллов - принято - любой скрипт
+1 балл - больше одного скрипта
+2 балла все скрипты
**************************************************************************************************************************************

** Реализация утилиты ps ax через парсинг файловой директории /proc **

Итоговые поля ps ax:
PID	Идентификатор процесса
TTY	Идентификатор управляющего терминала
STAT	Текущий статус процесса
TIME	Количество времени центрального процессора, затраченное на выполнение процесса
COMMAND	Имя и аргументы команды

* В данном сценарии вместо поля TTY я вставил: *
* %MEM Часть реальной памяти (в процентах), используемая процессом *
* (в формате вывода %MEM используется коэффициент 10 ввиду того что Bash не работает с натуральными числами) *

echo -e  "PID \t |MEM \t |STAT \t |TIME \t |CMD"
echo -e  "    \t |%*10\t |     \t |s/100\t |   "

* Формируем массив arraypid элементами которого являются PID запущенных процессов. *
array=($(ls -al /proc/ | awk {'print $9'}))
arraypid=()
for item in ${array[*]}
 do

* Проверка элемента является ли оно числом *
 if [ -n "$item" ] && [ "$item" -eq "$item" ] 2>/dev/null;
 then
        arraypid+=( $item )
 fi
 done

* Определение общего размера оперативной памяти *
globmem=( $(cat /proc/meminfo | grep MemTotal | awk {'print $2'}) )

for pid in ${arraypid[*]}
do

if [ $(cat /proc/$pid/status 2>/dev/null | grep VmRSS | awk {'print $2'} ) ];
then

* Для определения объема памяти, который этот процесс имеет в настоящее время в основной памяти (ОЗУ) *
* Используем RSS (резидентный виртуальный размер) *

        memproc=( $(cat /proc/$pid/status | grep VmRSS | awk {'print $2'}) )
        statproc=( $(cat /proc/$pid/status | grep Stat | awk {'print $2'}) )
        procent=$(($memproc*1000/$globmem))
    
* Для получения информации о времени, которое было затрачено на выполнение конкретным процессом *
* воспользуемся файлом /proc/<PID>/stat. *
* Он достаточно большой, нас интересует 2 поля: *
* 14-ое поле — utime - Время CPU, которое этот процесс затратил в user mode; *
* 15-ое поле — stime - Время CPU, которое этот процесс затратил в kernel mode; *
* Значение отображается в сотых долях секунды. *
    time=( $(cat /proc/$pid/stat | awk {'print $14'}) + $(cat /proc/$pid/stat | awk {'print $15'}))



* # cmd=( $(cat /proc/$pid/cmdline)) *
* После выполнения команды на более новой версии Bash появлялось: warning: command substitution: ignored null byte in input. *
* Я понимаю, что проблема заключается в завершении символа \0 в файле *
* пришлось немного сменить конструкцию что бы удалить нулевой байт: *
        cmd=$(tr -d '\0' <  /proc/$pid/cmdline)

        echo -e  "$pid \t |$procent \t |$statproc \t |$time \t |$cmd"
fi
done

